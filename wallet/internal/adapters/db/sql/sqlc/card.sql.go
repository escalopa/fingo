// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: card.sql

package sqlc

import (
	"context"
)

const createCard = `-- name: CreateCard :exec
INSERT INTO cards (number, account_id)
VALUES ($1, $2)
`

type CreateCardParams struct {
	Number    string `db:"number" json:"number"`
	AccountID int64  `db:"account_id" json:"account_id"`
}

func (q *Queries) CreateCard(ctx context.Context, db DBTX, arg CreateCardParams) error {
	_, err := db.ExecContext(ctx, createCard, arg.Number, arg.AccountID)
	return err
}

const deleteAccountCards = `-- name: DeleteAccountCards :exec
DELETE
FROM cards
WHERE account_id = $1
`

func (q *Queries) DeleteAccountCards(ctx context.Context, db DBTX, accountID int64) error {
	_, err := db.ExecContext(ctx, deleteAccountCards, accountID)
	return err
}

const deleteCard = `-- name: DeleteCard :exec
DELETE
FROM cards
WHERE number = $1
`

func (q *Queries) DeleteCard(ctx context.Context, db DBTX, number string) error {
	_, err := db.ExecContext(ctx, deleteCard, number)
	return err
}

const getAccountCards = `-- name: GetAccountCards :many
SELECT number, account_id
FROM cards
WHERE account_id = $1
`

func (q *Queries) GetAccountCards(ctx context.Context, db DBTX, accountID int64) ([]Card, error) {
	rows, err := db.QueryContext(ctx, getAccountCards, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Card{}
	for rows.Next() {
		var i Card
		if err := rows.Scan(&i.Number, &i.AccountID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCard = `-- name: GetCard :one
SELECT number, account_id
FROM cards
WHERE number = $1
`

func (q *Queries) GetCard(ctx context.Context, db DBTX, number string) (Card, error) {
	row := db.QueryRowContext(ctx, getCard, number)
	var i Card
	err := row.Scan(&i.Number, &i.AccountID)
	return i, err
}

const getCardAccount = `-- name: GetCardAccount :one
SELECT a.id as id, a.user_id as owner_id, a.name, a.balance, cc.name as currency
FROM cards c
       JOIN accounts a on a.id = c.account_id
       JOIN currency cc on a.currency_id = cc.id
WHERE c.number = $1
LIMIT 1
`

type GetCardAccountRow struct {
	ID       int64   `db:"id" json:"id"`
	OwnerID  int64   `db:"owner_id" json:"owner_id"`
	Name     string  `db:"name" json:"name"`
	Balance  float64 `db:"balance" json:"balance"`
	Currency string  `db:"currency" json:"currency"`
}

func (q *Queries) GetCardAccount(ctx context.Context, db DBTX, number string) (GetCardAccountRow, error) {
	row := db.QueryRowContext(ctx, getCardAccount, number)
	var i GetCardAccountRow
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Balance,
		&i.Currency,
	)
	return i, err
}

const getCardBalance = `-- name: GetCardBalance :one
SELECT balance
FROM accounts
WHERE id = (SELECT account_id
            FROM cards
            WHERE number = $1)
`

func (q *Queries) GetCardBalance(ctx context.Context, db DBTX, number string) (float64, error) {
	row := db.QueryRowContext(ctx, getCardBalance, number)
	var balance float64
	err := row.Scan(&balance)
	return balance, err
}

const getUserCards = `-- name: GetUserCards :many
SELECT cards.number, cards.account_id, accounts.currency_id
FROM cards
       INNER JOIN accounts ON accounts.id = cards.account_id
WHERE accounts.user_id = $1
`

type GetUserCardsRow struct {
	Number     string `db:"number" json:"number"`
	AccountID  int64  `db:"account_id" json:"account_id"`
	CurrencyID int64  `db:"currency_id" json:"currency_id"`
}

func (q *Queries) GetUserCards(ctx context.Context, db DBTX, userID int64) ([]GetUserCardsRow, error) {
	rows, err := db.QueryContext(ctx, getUserCards, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserCardsRow{}
	for rows.Next() {
		var i GetUserCardsRow
		if err := rows.Scan(&i.Number, &i.AccountID, &i.CurrencyID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
