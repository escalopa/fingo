// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: transaction.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createTransaction = `-- name: CreateTransaction :exec
INSERT INTO transactions (type, amount, source_account_id, destination_account_id)
VALUES ($1, $2, $3, $4)
RETURNING id
`

type CreateTransactionParams struct {
	Type                 TransactionType `db:"type" json:"type"`
	Amount               string          `db:"amount" json:"amount"`
	SourceAccountID      sql.NullInt32   `db:"source_account_id" json:"source_account_id"`
	DestinationAccountID sql.NullInt32   `db:"destination_account_id" json:"destination_account_id"`
}

func (q *Queries) CreateTransaction(ctx context.Context, db DBTX, arg CreateTransactionParams) error {
	_, err := db.ExecContext(ctx, createTransaction,
		arg.Type,
		arg.Amount,
		arg.SourceAccountID,
		arg.DestinationAccountID,
	)
	return err
}

const getTransaction = `-- name: GetTransaction :one
SELECT transactions.id, type, amount, source_account_id, destination_account_id
FROM transactions
WHERE id = $1
`

type GetTransactionRow struct {
	ID                   uuid.UUID       `db:"id" json:"id"`
	Type                 TransactionType `db:"type" json:"type"`
	Amount               string          `db:"amount" json:"amount"`
	SourceAccountID      sql.NullInt32   `db:"source_account_id" json:"source_account_id"`
	DestinationAccountID sql.NullInt32   `db:"destination_account_id" json:"destination_account_id"`
}

func (q *Queries) GetTransaction(ctx context.Context, db DBTX, id uuid.UUID) (GetTransactionRow, error) {
	row := db.QueryRowContext(ctx, getTransaction, id)
	var i GetTransactionRow
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Amount,
		&i.SourceAccountID,
		&i.DestinationAccountID,
	)
	return i, err
}

const getTransactions = `-- name: GetTransactions :many
SELECT transactions.id,
       transactions.amount,
       type,
       source.name      as from_account_name,
       destination.name as to_account_name,
       created_at
FROM transactions
       JOIN accounts destination on destination.id = transactions.destination_account_id
       JOIN accounts source on destination.id = transactions.source_account_id
WHERE source.id = $1
   OR destination.id = $1
  AND coalesce($2, type) = type
  AND coalesce($3, created_at) = created_at
  AND coalesce($4, created_at) = created_at
  AND coalesce($5, transactions.amount) <= transactions.amount
  AND coalesce($6, transactions.amount) >= transactions.amount
  AND coalesce($7, transactions.is_rolled_back) = transactions.is_rolled_back
ORDER BY created_at DESC
LIMIT $9 OFFSET $8
`

type GetTransactionsParams struct {
	AccountID       int32               `db:"account_id" json:"account_id"`
	TransactionType NullTransactionType `db:"transaction_type" json:"transaction_type"`
	FromDate        sql.NullTime        `db:"from_date" json:"from_date"`
	ToDate          sql.NullTime        `db:"to_date" json:"to_date"`
	FromAmount      sql.NullString      `db:"from_amount" json:"from_amount"`
	ToAmount        sql.NullString      `db:"to_amount" json:"to_amount"`
	IsRolledBack    sql.NullBool        `db:"is_rolled_back" json:"is_rolled_back"`
	Offset          int32               `db:"offset" json:"offset"`
	Limit           int32               `db:"limit" json:"limit"`
}

type GetTransactionsRow struct {
	ID              uuid.UUID       `db:"id" json:"id"`
	Amount          string          `db:"amount" json:"amount"`
	Type            TransactionType `db:"type" json:"type"`
	FromAccountName string          `db:"from_account_name" json:"from_account_name"`
	ToAccountName   string          `db:"to_account_name" json:"to_account_name"`
	CreatedAt       time.Time       `db:"created_at" json:"created_at"`
}

func (q *Queries) GetTransactions(ctx context.Context, db DBTX, arg GetTransactionsParams) ([]GetTransactionsRow, error) {
	rows, err := db.QueryContext(ctx, getTransactions,
		arg.AccountID,
		arg.TransactionType,
		arg.FromDate,
		arg.ToDate,
		arg.FromAmount,
		arg.ToAmount,
		arg.IsRolledBack,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTransactionsRow{}
	for rows.Next() {
		var i GetTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.Type,
			&i.FromAccountName,
			&i.ToAccountName,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
