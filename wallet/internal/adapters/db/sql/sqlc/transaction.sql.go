// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: transaction.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createDepositTransaction = `-- name: CreateDepositTransaction :exec
INSERT INTO transactions(type, amount, destination_account_id)
VALUES ('deposit', $1, $2)
`

type CreateDepositTransactionParams struct {
	Amount               float64       `db:"amount" json:"amount"`
	DestinationAccountID sql.NullInt64 `db:"destination_account_id" json:"destination_account_id"`
}

func (q *Queries) CreateDepositTransaction(ctx context.Context, db DBTX, arg CreateDepositTransactionParams) error {
	_, err := db.ExecContext(ctx, createDepositTransaction, arg.Amount, arg.DestinationAccountID)
	return err
}

const createTransferTransaction = `-- name: CreateTransferTransaction :exec
INSERT INTO transactions (type, amount, source_account_id, destination_account_id)
VALUES ('transfer', $1, $2, $3)
`

type CreateTransferTransactionParams struct {
	Amount               float64       `db:"amount" json:"amount"`
	SourceAccountID      sql.NullInt64 `db:"source_account_id" json:"source_account_id"`
	DestinationAccountID sql.NullInt64 `db:"destination_account_id" json:"destination_account_id"`
}

func (q *Queries) CreateTransferTransaction(ctx context.Context, db DBTX, arg CreateTransferTransactionParams) error {
	_, err := db.ExecContext(ctx, createTransferTransaction, arg.Amount, arg.SourceAccountID, arg.DestinationAccountID)
	return err
}

const createWithdrawTransaction = `-- name: CreateWithdrawTransaction :exec
INSERT INTO transactions(type, amount, source_account_id)
VALUES ('withdrawal', $1, $2)
`

type CreateWithdrawTransactionParams struct {
	Amount          float64       `db:"amount" json:"amount"`
	SourceAccountID sql.NullInt64 `db:"source_account_id" json:"source_account_id"`
}

func (q *Queries) CreateWithdrawTransaction(ctx context.Context, db DBTX, arg CreateWithdrawTransactionParams) error {
	_, err := db.ExecContext(ctx, createWithdrawTransaction, arg.Amount, arg.SourceAccountID)
	return err
}

const getTransaction = `-- name: GetTransaction :one
SELECT t.id,
       t.type,
       t.amount,
       source.id        as from_account_id,
       source.name      as from_account_name,
       destination.id   as to_account_id,
       destination.name as to_account_name,
       t.created_at,
       t.is_rolled_back
FROM transactions t
       LEFT JOIN accounts destination on destination.id = t.destination_account_id
       LEFT JOIN accounts source on source.id = t.source_account_id
WHERE t.id = $1
`

type GetTransactionRow struct {
	ID              uuid.UUID       `db:"id" json:"id"`
	Type            TransactionType `db:"type" json:"type"`
	Amount          float64         `db:"amount" json:"amount"`
	FromAccountID   sql.NullInt64   `db:"from_account_id" json:"from_account_id"`
	FromAccountName sql.NullString  `db:"from_account_name" json:"from_account_name"`
	ToAccountID     sql.NullInt64   `db:"to_account_id" json:"to_account_id"`
	ToAccountName   sql.NullString  `db:"to_account_name" json:"to_account_name"`
	CreatedAt       time.Time       `db:"created_at" json:"created_at"`
	IsRolledBack    bool            `db:"is_rolled_back" json:"is_rolled_back"`
}

func (q *Queries) GetTransaction(ctx context.Context, db DBTX, id uuid.UUID) (GetTransactionRow, error) {
	row := db.QueryRowContext(ctx, getTransaction, id)
	var i GetTransactionRow
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Amount,
		&i.FromAccountID,
		&i.FromAccountName,
		&i.ToAccountID,
		&i.ToAccountName,
		&i.CreatedAt,
		&i.IsRolledBack,
	)
	return i, err
}

const getTransactions = `-- name: GetTransactions :many
SELECT t.id,
       t.amount,
       t.type,
       source.name      as from_account_name,
       destination.name as to_account_name,
       t.created_at,
       t.is_rolled_back
FROM transactions t
       LEFT JOIN accounts destination on destination.id = t.destination_account_id
       LEFT JOIN accounts source on source.id = t.source_account_id
WHERE (source.id = $1
  OR destination.id = $1)
  AND coalesce($2, t.amount) <= t.amount
  AND coalesce($3, t.amount) >= t.amount
ORDER BY created_at DESC
LIMIT $5 OFFSET $4
`

type GetTransactionsParams struct {
	AccountID int64           `db:"account_id" json:"account_id"`
	MinAmount sql.NullFloat64 `db:"min_amount" json:"min_amount"`
	MaxAmount sql.NullFloat64 `db:"max_amount" json:"max_amount"`
	Offset    int32           `db:"offset" json:"offset"`
	Limit     int32           `db:"limit" json:"limit"`
}

type GetTransactionsRow struct {
	ID              uuid.UUID       `db:"id" json:"id"`
	Amount          float64         `db:"amount" json:"amount"`
	Type            TransactionType `db:"type" json:"type"`
	FromAccountName sql.NullString  `db:"from_account_name" json:"from_account_name"`
	ToAccountName   sql.NullString  `db:"to_account_name" json:"to_account_name"`
	CreatedAt       time.Time       `db:"created_at" json:"created_at"`
	IsRolledBack    bool            `db:"is_rolled_back" json:"is_rolled_back"`
}

// AND coalesce(sqlc.narg('transaction_type') IS NULL, t.type) = t.type
func (q *Queries) GetTransactions(ctx context.Context, db DBTX, arg GetTransactionsParams) ([]GetTransactionsRow, error) {
	rows, err := db.QueryContext(ctx, getTransactions,
		arg.AccountID,
		arg.MinAmount,
		arg.MaxAmount,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTransactionsRow{}
	for rows.Next() {
		var i GetTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.Type,
			&i.FromAccountName,
			&i.ToAccountName,
			&i.CreatedAt,
			&i.IsRolledBack,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setTransactionRolledBack = `-- name: SetTransactionRolledBack :exec
UPDATE transactions
SET is_rolled_back = true
WHERE id = $1
`

func (q *Queries) SetTransactionRolledBack(ctx context.Context, db DBTX, id uuid.UUID) error {
	_, err := db.ExecContext(ctx, setTransactionRolledBack, id)
	return err
}
