// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: transaction.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createTransaction = `-- name: CreateTransaction :exec
INSERT INTO transactions (type, amount, source_account_id, destination_account_id)
VALUES ($1, $2, $3, $4)
RETURNING id
`

type CreateTransactionParams struct {
	Type                 TransactionType `db:"type" json:"type"`
	Amount               string          `db:"amount" json:"amount"`
	SourceAccountID      sql.NullInt32   `db:"source_account_id" json:"source_account_id"`
	DestinationAccountID sql.NullInt32   `db:"destination_account_id" json:"destination_account_id"`
}

func (q *Queries) CreateTransaction(ctx context.Context, db DBTX, arg CreateTransactionParams) error {
	_, err := db.ExecContext(ctx, createTransaction,
		arg.Type,
		arg.Amount,
		arg.SourceAccountID,
		arg.DestinationAccountID,
	)
	return err
}

const getTransaction = `-- name: GetTransaction :one
SELECT transactions.id, type, amount, source_account_id, destination_account_id
FROM transactions
WHERE id = $1
`

type GetTransactionRow struct {
	ID                   int32           `db:"id" json:"id"`
	Type                 TransactionType `db:"type" json:"type"`
	Amount               string          `db:"amount" json:"amount"`
	SourceAccountID      sql.NullInt32   `db:"source_account_id" json:"source_account_id"`
	DestinationAccountID sql.NullInt32   `db:"destination_account_id" json:"destination_account_id"`
}

func (q *Queries) GetTransaction(ctx context.Context, db DBTX, id int32) (GetTransactionRow, error) {
	row := db.QueryRowContext(ctx, getTransaction, id)
	var i GetTransactionRow
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Amount,
		&i.SourceAccountID,
		&i.DestinationAccountID,
	)
	return i, err
}

const getTransactionsByAccount = `-- name: GetTransactionsByAccount :many
SELECT transactions.id,
       type,
       transactions.amount,
       source.name            as from_account_name,
       source_account_id      as from_account_id,
       destination.name       as to_account_name,
       destination_account_id as to_account_id,
       created_at
FROM transactions
       JOIN accounts destination on destination.id = transactions.destination_account_id
       JOIN accounts source on destination.id = transactions.source_account_id
WHERE (source_account_id = $1 OR destination_account_id = $1)
`

type GetTransactionsByAccountRow struct {
	ID              int32           `db:"id" json:"id"`
	Type            TransactionType `db:"type" json:"type"`
	Amount          string          `db:"amount" json:"amount"`
	FromAccountName string          `db:"from_account_name" json:"from_account_name"`
	FromAccountID   sql.NullInt32   `db:"from_account_id" json:"from_account_id"`
	ToAccountName   string          `db:"to_account_name" json:"to_account_name"`
	ToAccountID     sql.NullInt32   `db:"to_account_id" json:"to_account_id"`
	CreatedAt       time.Time       `db:"created_at" json:"created_at"`
}

func (q *Queries) GetTransactionsByAccount(ctx context.Context, db DBTX, sourceAccountID sql.NullInt32) ([]GetTransactionsByAccountRow, error) {
	rows, err := db.QueryContext(ctx, getTransactionsByAccount, sourceAccountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTransactionsByAccountRow{}
	for rows.Next() {
		var i GetTransactionsByAccountRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Amount,
			&i.FromAccountName,
			&i.FromAccountID,
			&i.ToAccountName,
			&i.ToAccountID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByAccountAndDate = `-- name: GetTransactionsByAccountAndDate :many
SELECT transactions.id,
       type,
       transactions.amount,
       source.name            as from_account_name,
       source_account_id      as from_account_id,
       destination.name       as to_account_name,
       destination_account_id as to_account_id,
       created_at
FROM transactions
       JOIN accounts destination on destination.id = transactions.destination_account_id
       JOIN accounts source on destination.id = transactions.source_account_id
WHERE (source_account_id = $1 OR destination_account_id = $1)
  AND created_at >= $2
  AND created_at <= $3
`

type GetTransactionsByAccountAndDateParams struct {
	SourceAccountID sql.NullInt32 `db:"source_account_id" json:"source_account_id"`
	CreatedAt       time.Time     `db:"created_at" json:"created_at"`
	CreatedAt_2     time.Time     `db:"created_at_2" json:"created_at_2"`
}

type GetTransactionsByAccountAndDateRow struct {
	ID              int32           `db:"id" json:"id"`
	Type            TransactionType `db:"type" json:"type"`
	Amount          string          `db:"amount" json:"amount"`
	FromAccountName string          `db:"from_account_name" json:"from_account_name"`
	FromAccountID   sql.NullInt32   `db:"from_account_id" json:"from_account_id"`
	ToAccountName   string          `db:"to_account_name" json:"to_account_name"`
	ToAccountID     sql.NullInt32   `db:"to_account_id" json:"to_account_id"`
	CreatedAt       time.Time       `db:"created_at" json:"created_at"`
}

func (q *Queries) GetTransactionsByAccountAndDate(ctx context.Context, db DBTX, arg GetTransactionsByAccountAndDateParams) ([]GetTransactionsByAccountAndDateRow, error) {
	rows, err := db.QueryContext(ctx, getTransactionsByAccountAndDate, arg.SourceAccountID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTransactionsByAccountAndDateRow{}
	for rows.Next() {
		var i GetTransactionsByAccountAndDateRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Amount,
			&i.FromAccountName,
			&i.FromAccountID,
			&i.ToAccountName,
			&i.ToAccountID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByAccountAndType = `-- name: GetTransactionsByAccountAndType :many
SELECT transactions.id,
       type,
       transactions.amount,
       source.name            as from_account_name,
       source_account_id      as from_account_id,
       destination.name       as to_account_name,
       destination_account_id as to_account_id,
       transactions.created_at
FROM transactions
       JOIN accounts destination on destination.id = transactions.destination_account_id
       JOIN accounts source on destination.id = transactions.source_account_id
WHERE (source_account_id = $1 OR destination_account_id = $1)
  AND type = $2
`

type GetTransactionsByAccountAndTypeParams struct {
	SourceAccountID sql.NullInt32   `db:"source_account_id" json:"source_account_id"`
	Type            TransactionType `db:"type" json:"type"`
}

type GetTransactionsByAccountAndTypeRow struct {
	ID              int32           `db:"id" json:"id"`
	Type            TransactionType `db:"type" json:"type"`
	Amount          string          `db:"amount" json:"amount"`
	FromAccountName string          `db:"from_account_name" json:"from_account_name"`
	FromAccountID   sql.NullInt32   `db:"from_account_id" json:"from_account_id"`
	ToAccountName   string          `db:"to_account_name" json:"to_account_name"`
	ToAccountID     sql.NullInt32   `db:"to_account_id" json:"to_account_id"`
	CreatedAt       time.Time       `db:"created_at" json:"created_at"`
}

func (q *Queries) GetTransactionsByAccountAndType(ctx context.Context, db DBTX, arg GetTransactionsByAccountAndTypeParams) ([]GetTransactionsByAccountAndTypeRow, error) {
	rows, err := db.QueryContext(ctx, getTransactionsByAccountAndType, arg.SourceAccountID, arg.Type)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTransactionsByAccountAndTypeRow{}
	for rows.Next() {
		var i GetTransactionsByAccountAndTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Amount,
			&i.FromAccountName,
			&i.FromAccountID,
			&i.ToAccountName,
			&i.ToAccountID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
